---
title: "Уровни изоляции транзакций в БД"
source: "https://habr.com/ru/articles/845522/"
author:
  - "[[Хабр]]"
published: 2024-09-24
created: 2025-05-03
description: "В этой статье я собрал сводку базовых знаний об уровнях изолированности транзакций. Понятно, что для полного погружения нужно копать глубже, да и использование уровней отличается в зависимости от..."
tags:
  - "clippings"
---
C этой статье я собрал сводку базовых знаний об уровнях изолированности транзакций. Понятно, что для полного погружения нужно копать глубже, да и использование уровней отличается в зависимости от СУБД, но кажется, что **для первого знакомства** с изоляцией транзакций в БД этой статьи должно быть вполне достаточно. Если ваш опыт отличается от того, что описано в статье (а это вполне возможно), то приглашаю в комментарии:)

---

Уровень изоляции (изоляция или изолированность — это, кстати, буква « **I** » в аббревиатуре [**ACID**](https://ru.wikipedia.org/wiki/ACID) — « **Isolation** ») определяет, как транзакции могут взаимодействовать между собой, и насколько сильно могут пересекаться и мешать друг другу при параллельной работе. Иначе говоря, разные уровни изоляции допускают или не допускают разные **аномалии** при параллельной работе транзакций (про аномалии расскажем дальше).

Всего есть 4 основных уровня изоляции:

 - [[READ UNCOMMITTED]]
 - [[READ COMMITTED]]
 - [[REPEATABLE READ]]
 - [[SERIALIZABLE]]

### Другие уровни изоляции

Кроме стандартных перечисленных уровней изоляции есть ещё специфичные уровни **READ STABILITY** и **CURSOR STABILITY**, которые используются в [Db2](https://www.ibm.com/db2) (СУБД от IBM) - они предлагают уже более тонкую настройку изоляции.

**CURSOR STABILITY (CS)** блокирует текущую строку, прочитанную через некий курсор (курсор мы специально ставим в запросе, и он будет, например, ходить по каждой строке нашего запроса по порядку). С уровнем CURSOR STABILITY мы блокируем только ту строку, на которой сейчас находится курсор.

**READ STABILITY (RS)** обеспечивает ситуацию, когда данные, прочитанные одной транзакцией, не будут изменены другой транзакцией до завершения первой транзакции. Т. е. тут нет проблемы неповторяющегося чтения, но могут быть фантомные чтения.

Тут углубляться не будем — эти уровни достаточно специфичные и актуальны именно для Db2 (по крайней мере, я их не встречал в других СУБД).

В **SQL Server** есть ещё [**SNAPSHOT ISOLATION**](https://learn.microsoft.com/ru-ru/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server) (многоверсионная изоляция), которая позволяет транзакциям видеть снимок базы данных на момент начала транзакциии, устраняя тем самым фантомное чтение и неповторяющееся чтение и не блокирует данные при их чтении, что обеспечивает параллелизм (одновременное чтение одних и тех же данных разными транзакциями) - здесь, опять же, вспоминаем про **MVCC**, на основе которого работает данный уровень (ещё чуть-чуть и мы до него доберёмся). Но SNAPSHOT ISOLATION не гарантирует полную сериализуемость, т. к. возможны конфликты при записи, когда две транзакции пытаются изменить одну и ту же запись (тогда одна из операций упадёт в ошибку).  
Нечто похожее есть в **PostgreSQL** - [**SERIALIZABLE SNAPSHOT ISOLATION (SSI)**](https://wiki.postgresql.org/wiki/SSI), который тоже работает с версиями базы и использует технологию MVCC, из-за чего самый жёсткий и "непараллельный" классический уровень SERIALIZABLE становится намного более удобным, т. к. SSI эффективно работает с конфликтами, а не жёстко блокирует диапазоны.

### Что такое MVCC

Уже несколько раз мы упоминали MVCC, который в InnoDB не допускает фантомное чтение уже на уровне REPEATABLE READ, а в SQL Server и PostgreSQL позволяет отдельным уровням изоляции эффективно работать с параллельными запросами. Так что это за зверь?

**MVCC** (**Multiversion Concurrency Control**) — это метод управления конкурентным доступом к данным в БД, который **позволяет нескольким транзакциям работать с данными одновременно без конфликтов**. MVCC поддерживает высокую производительность и изоляцию транзакций, минимизируя блокировки и улучшая параллелизм.

Но как он это делает?

- **Многоверсионность**:
	MVCC использует механизм многоверсионности для управления изменениями данных. Вместо того чтобы изменять данные в месте их хранения, MVCC создает новые версии данных. Каждая транзакция видит данные в том состоянии, в котором они были на момент начала транзакции, а не в текущем состоянии.
	При записи данных создается новая версия строки. Новая версия включает информацию о том, какая транзакция создала ее, и становится видимой для транзакций, которые начинаются после ее создания.
	Благодаря тому, что в версии указано, какая транзакция создала её и когда данные были созданы или удалены, можно определить, какая версия доступна для конкретной транзакции.
	Время от времени СУБД очищает старые версии данных, которые больше не нужны (т. е. которые уже не используются ни одной транзакцией). Это называется сбором мусора и помогает поддерживать эффективность системы.
- **Изоляция транзакций**:
	Транзакции видят только те данные, которые были зафиксированы до их начала. Это предотвращает грязное чтение, неповторяющееся чтение и фантомное чтение.
- **Отсутствие блокировок для чтения**:
	Чтение данных не блокирует запись, а запись не блокирует чтение. Это повышает производительность системы, поскольку транзакции могут работать с данными параллельно.
- **Управление конфликтами**:
	Конфликты между транзакциями, например, две транзакции, пытающиеся изменить одну и ту же строку, решаются при коммите транзакций. Если одна из транзакций не может быть закоммичена из‑за конфликта, её можно откатить.
	В итоге, MVCC — это такая штука, которая позволяет каждой транзакции работать с её собственной версией базы (грубо говоря), не влияя на остальные транзакции и не блокируя данные. **Важный момент** - MVCC реализован в разных СУБД, как мы уже говорили, но в каждой из них имеет свою форму и специфику, поэтому лучше смотреть на конкретно ваш кейс с вашей СУБД, чтобы понять нюансы работы.

### Как можно переключаться между уровнями?

Конкретный уровень изоляции можно подключать с помощью команды **SET ISOLATION LEVEL**, и можно также назначить, на какие транзакции будет действовать подключаемый уровень.

На примере подключения уровня REPEATABLE READ в MySQL (в других СУБД команды могут отличаться):

```sql
--Будет действовать на 1 следующую транзакцию в текущей сессии
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    
    --Будет действовать на все транзакции в текущей сессии
    SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    --Вариант включения уровня изоляции в PostgreSQL
    SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    
    --Будет действовать на все транзакции
    SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

### А если столкнуть две транзакции с разными уровнями изоляции?

Если параллельно работают несколько транзакций с разными уровнями изоляции, то могут возникать проблемы с видимостью данных и появляться наши любимые аномалии. Опять же, тут всё зависит от вашей СУБД, но вот несколько базовых понятий:

- Транзакция с высоким уровнем изоляции (например, SERIALIZABLE) блокирует ресурсы более строго, что может привести к блокировкам для других транзакций с более низким уровнем изоляции (например, READ UNCOMMITTED или READ COMMITTED);
- Если транзакция с более низким уровнем изоляции пытается получить доступ к данным, которые заблокированы более изолированной транзакцией, она будет ждать, пока та не завершится (или не будет отменена);
- Транзакция с низким уровнем изоляции (например, READ UNCOMMITTED) может видеть незавершенные изменения других транзакций и не блокирует их, что может привести к ситуациям, когда она читает данные, которые в итоге могут быть отменены в более изолированной транзакции.

+18

Вышла LLM Qwen3

Будущее здесь: лучшее

Годнота из блогов компаний

Открыт приём в Школу анализа данных

Электроны зажигают!

Сезону Open source нужны твои истории

[Администратор баз данных](https://career.habr.com/vacancies/administrator_baz_dannykh)

96 вакансий