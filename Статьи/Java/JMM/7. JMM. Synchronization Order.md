## JMM: Synchronization Order

  

Как мы уже знаем, JMM — это слабая модель памяти, которая не соблюдает порядок программы. Поэтому модель должна нам предоставить специальные примитивы, при использовании которых гарантировался бы консистентный порядок.

  

И такое решение действительно есть: JMM предоставляет специальные примитивы под названием *Synchronization Actions (SA)*. Для таких действий образуется полный порядок под названием *Synchronization Order (SO)*, в котором:

  
1. Порядок действий *консистентен с порядком программы*
2. Каждое чтение всегда видит предыдущую запись
  

[JLS 17.4.4. Synchronization Order](https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.4.4):

  

> Every execution has a *synchronization order*. A synchronization order is a total order over all of the synchronization actions of an execution. For each thread `t`, the synchronization order of the synchronization actions (§17.4.2) in `t` is consistent with the program order (§17.4.3) of `t`.

Постойте, но это же звучит как Sequential Consistency? Именно так — SO это SC!

  

Нас интересуют следующие synchronization actions:

  
1. Запись и чтение `volatile` переменной
2. Взятие и освобождение монитора
  

Давайте сразу перейдем к практике. Например, если в Dekker lock мы пометим обе переменные как `volatile`, то свяжем все действия с переменными в SO и получим только SC выполнения:

  
```java
public class DekkerVolatile {
   private volatile int x;
   private volatile int y;

   public void T1() {
      x = 1;
      int r1 = y;
   }

   public void T2() {
      y = 1;
      int r2 = x;
   }
}
```
  

Ранее мы уже перечисляли все возможные SC порядки, поэтому не будем их повторять. Давайте лучше для нагладяности перечислим порядки, которые *не подчиняются* свойствам SO, а поэтому не считаются валидными с точки зрения JMM:

  
```
write(x, 1) --SO-> read(y):0 --non-SO-> read(x):1 --non-SO-> write(y, 1) // violates SO-PO consistency - not consistent with program order
read(y):0 --non-SO-> read(x):0 --non-SO-> write(x, 1) --non-SO-> write(y, 1) // violates SO-PO consistency - not consistent with program order
write(x, 1) --SO-> write(y, 1) -> read(y):0 --SO-> read(x):0 // violates SO consistency - does not see preceding writes
```
  

Итак, мы получили Sequential Consistency, и на этом разговор о JMM можно завершать. Всем спасибо за внимание.

  

Шучу. Заметим, что SO предлагает нам все или ничего: или мы используем только synchronization actions (например, помечаем все shared переменные как volatile) и получаем SC, или не получаем ничего, ведь не-SA действия (обычные записи и чтения shared переменной) снова будут выполняться в неконсистентном порядке, нарушая корректность программы.

  

Более того, синхронизировать всю программу таким способом просто неудобно: представьте, что вы пишете объект с кучей полей — вам придется пометить как внутренние поля, так и ссылку на объект как `volatile`. Иначе вы рискуете получить такое StoreStore переупорядочивание, что запись ссылки произойдет до записей из конструктора (как минимум для процессора это все одно и то же, поэтому он способен сделать такое переупорядочивание).

  

Давайте теперь зададимся вопросом: зачем вообще JMM явно предоставляет SA, если можно было бы сделать все действия такими неявно и дать нам SC по-умолчанию? Сиди и помечай все переменные как `volatile`, нам ведь заняться нечем.

  

Хотя связать все действия с shared данными в SO иногда бывает необходимо (как в Dekker локе или [IRIW](https://github.com/openjdk/jcstress/blob/master/tests-custom/src/main/java/org/openjdk/jcstress/tests/volatiles/VolatileIRIWTest.java) тесте), но в большинстве случаев это избыточно и запретит многие оптимизации компилятора, ухудшив производительность программы. Да, SO/SC действительно представляют собой лишь иллюзию последовательного выполнения, но многие оптимизации все равно будут запрещены. Именно поэтому ни в каком языке или микроархитектуре мы никогда не встретим SC модели по-умолчанию.

  

Так вот, в JMM существует основанный на SA формальный способ разрешить оптимизации под капотом, при этом все так же дав пользователям возможность писать корректные программы. И вот наконец мы начинаем говорить о частичном *happens-before (hb)* порядке, который все так же гарантирует консистентный порядок и видимость изменений, но при этом является намного более удобным в использовании и позволяет нам не синхронизировать всю программу.

  

---

  
