## Как JMM обеспечивает консистентный memory order: подводим итоги

  

Итак, давайте резюмируем, что делает JMM на каждом из уровней, чтобы правильно синхронизированная программа не имела переупорядочиваний. Happens-before — это конечно хорошо, но это всего лишь абстракция. А вот на нижнем уровне компилятора и хардвара JMM на самом деле делает следующее:

  
1. Compiler memory ordering  
	1. Уровень компилятора байткода (`javac`)  
		- Обеспечивает такой порядок сгенерированных bytecode инструкций, который будет консистентен с порядком действий в коде
	2. Уровень компилятора машинного кода (`HotSpot JIT Compiler C1/C2`)  
		- Обеспечивает такой порядок сгенерированных машинных инструкций, который будет консистентен с порядком действий в коде
2. CPU memory ordering  
	- Расставляет барьеры памяти в нужных местах так, чтобы memory ordering машинных инструкций был консистентен с порядком действий в коде
  

Первые два уровня зависят полностью от самой Java — именна она имплементирует гарантию порядка. Уровень процессора же зависит не только от Java, но и от самого процессора, который предоставляет и имплементирует барьеры памяти.

  

---

  
