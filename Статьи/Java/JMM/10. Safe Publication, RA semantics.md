## Safe Publication/RA semantics

  

Наверняка вы заметили, что в обоих примерах прослеживается некая идиома: делаем все необходимые изменения до некоторого синхронизирующего треды действия `A` (запись в `volatile` переменную, освобождение лока), а читаем эти изменения после другого синхронизирующего действия `B` (чтение `volatile` переменной, взятие лока) — это называется *[acquire/release семантика](https://preshing.com/20120913/acquire-and-release-semantics/)* или *Safe Publication* (безопасная публикация). Наверняка, многие из вас слышали последнее понятие.

  

Можно сказать, что release действие паблишит все изменения другим тредам, а acquire действие принимает эти изменения. Если говорить более формально, то release семантика запрещает переупорядочивание release действия с записями, идущими в порядке программе ранее (StoreStore), а acquire семантика запрещает переупорядочивание acquire действия с чтениями, идущими в порядке программы позже (LoadLoad). Конечно, это всего лишь высокоуровневая интерпретация свойств happens-before и таких терминов вы не найдете в спеке, но для простоты понимания можно вполне мыслить в рамках "безопасной публикации".

  

| Thread 1 | Thread 2 |
| --- | --- |
| ...writes... |  |
| release | acquire |
|  | ...reads... |

  

Именно благодаря тому, что happens-before порядок не требует строгого порядка для обычных записей/чтений, все действия до release или после acquire могут быть переупорядочены под капотом как угодно. Но главное то, что они не будут переупорядочены с самим release/acquire действием. Например, если мы имеем действия `[W1, W2, W3, RELEASE]`, то `[W1, W2, W3]` могут быть переупорядочены под капотом как угодно, но они всегда будут выполнены до `RELEASE` действия.

  

Безопасная публикация распространяется и на объекты — взгляните на следующий пример:

  
```java
public class JmmReorderingObjectExample {
    private Foo instance;

    private static class Foo {
        private int x;

        Foo() {
            this.x = 5; /* W1 */
        }
    }

    public void writer() {
        instance = new Foo(); /* W2, non-safe publish */
    }

    public void reader() {
        Foo r1 = instance; /* R1 */
        if (r1 != null) {
           int r2 = r1.x; /* R2: may be default value (0) */
        }
    }
}
```
  

В данной программе мы можем наблюдать дефолтное значение на чтении `R2` из-за StoreStore переупорядочивания (запись ссылки `W2` произошла перед записью в конструкторе `W1`) или LoadLoad переупорядочивания (чтение `R2` случилось перед чтением `R1`).

  

Но как только мы пометим переменную `instance` как `volatile` или будем читать/писать под монитором, то такие переупорядочивания будут невозможны благодаря транзитивности happens-before:

  
```
write(x, 5) --hb-> write(volatile instance, ref) --hb-> read(volatile instance):ref -> read(x): 5
monitorEnter() --hb-> write(x, 5) --hb-> write(instance, ref) --hb-> monitorExit() --hb-> monitorEnter() --hb-> read(instance):ref --hb-> read(x): 5 --hb-> monitorExit()
```
  

Смотрите jcstress тесты, наглядно демонстрирующие безопасную публикацию объектов — [https://github.com/blinky-z/JmmArticleHabr/tree/main/jcstress/tests/object](https://github.com/blinky-z/JmmArticleHabr/tree/main/jcstress/tests/object).

  

Как видите, пользоваться happens-before достаточно просто. Анализируйте свою программу: в большинстве случаев применима именно безопасная публикация, которая гарантирует вам видимость всех сделанных изменений. И только в редких случаях вам придется связать все действия в Synchronization Order как в случае с Dekker локом. В любом случае, оба способа гарантируют вам отсутствие гонок и sequentially consistent результаты.

  

---

  
