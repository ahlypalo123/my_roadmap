## Введение: JMM

  

Теперь, получив контекст и поняв проблемы, можно начать говорить о JMM.

  

Мы поняли, что as-if-serial семантики недостаточно для многопоточных программ. Почему же не распространить as-if-serial гарантию на всю программу и ядра процессора? Ответ простой — это сильно ударило бы по производительности программ или процессора.

  

Одно из решений описанных проблем — это начать полагаться на строгие гарантии определенной микро-архитектуры процессора или имплементации компилятора/JVM. Но это очень хрупкое решение, которое заставляет думать о среде запуска программы, что препятствует кросс-платформенности. Например, ARM архитектура обладает гораздо более слабыми гарантиями по сравнению с x86: мы можем обнаружить намного больше багов в программе, если однажды стабильно работавшую на x86 программу запустим на ARM. Более того, обычно компиляторы не дают никаких гарантий, а вольны делать любые оптимизации.

  

В общем, нам нужна поддержка со стороны спецификации языка. Поэтому более надежное решение — это создание так называемой *модели памяти* (memory model), которая строго описывает какое выполнение программы является валидным. Модель памяти делает легальными многие оптимизации компилятора, JVM и процессора, но в то же время закрепляет условия, при которых программа будет вести себя корректно в многопоточной среде даже в присутствие оптимизаций. Таким образом, модель памяти:

  
- Разрешает выполнение различных оптимизаций компилятора, JVM или процессора
- Строго закрепляет условия, при которых программа считается правильно синхронизированной, и закрепляет поведение правильно синхронизированных программ
- Описывает отношение между высокоуровневым кодом и памятью
- Является trade-off между строгостью исполнения кода и возможными оптимизациями
  

Так вот, Java имеет свою модель памяти под названием **Java Memory Model** (JMM). По умолчанию JMM разрешает любые переупорядочивания и не гарантирует видимости изменений. Однако *при выполнении определенных условий* нам гарантируется порядок действий, консистентный с порядком в коде, а также видимость всех изменений. Таким образом, JMM позволяет нам писать программы, которые будут полностью корректно работать среди множества различных имплементаций JDK и микро-архитектур процессоров, в то же время сохраняя преимущества оптимизаций.

  

---

  
