## Введение: Sequential Consistency: Why?

  

Вы наверное сейчас сидите и думаете: абстракция над абстракцией и абстракцией погоняет… Memory model, memory order, sequential consistency… Ну зачем, зачем же все эти абстракции? Давайте вместе разбираться.

  

Посмотрим на определение Sequential Consistency еще раз:

  

> ...the result of any execution **is the same as if** the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.

Обратите внимание на выделенное в определении *"is the same as if"* — это очень важная деталь. Это означает, что инструкции под капотом не должны выполняться именно в sequential порядке. Важно лишь то, чтобы результат выполнения был *не отличим* от одного из таких порядков.

  

Хорошо, а нам то что с этого? А нам ничего. Зато разработчикам JMM такое определение позволяет делать любые оптимизации под капотом, пока они не приводят к результату, который не возможен в SC выполнении.

  

Давайте разберем подробнее. Снова возвращаемся к нашей программе:

  

| Thread 0 | Thread 1 |
| --- | --- |
| x = 1 | y = 1 |
| r1 = y | r2 = x |

  

Снова перечисляем все возможные sequentially consistent порядки, где каждому выполнению запишем конечный результат:

  
```
write(x, 1) -> write(y, 1) -> read(y):1 -> read(x):1 // result: (x,y)=(1, 1)
write(x, 1) -> write(y, 1) -> read(x):1 -> read(y):1 // result: (x,y)=(1, 1)
write(x, 1) -> read(y):0 -> write(y, 1) -> read(x):1 // result: (x,y)=(1, 0)

write(y, 1) -> write(x, 1) -> read(x):1 -> read(y):1 // result: (x,y)=(1, 1)
write(y, 1) -> write(x, 1) -> read(y):1 -> read(x):1 // result: (x,y)=(1, 1)
write(y, 1) -> read(x):0 -> write(x, 1) -> read(y):1 // result: (x,y)=(0, 1)
```
  

В итоге мы получаем следующий сет возможных результатов: `(0, 1), (1, 0), (1, 1)`. Назовем такие результаты *"sequentially consistent results"*.

  

Так вот, любая имплементация нашей программы, которая гарантированно приводит *к одному из* sequentially consistent результатов, является валидной вне зависимости от того, какие оптимизации были сделаны. Главное то, чтобы эти оптимизации не могли привести к sequentially inconsistent результату.

  

Например, в SC модели памяти компилятор не может вот так переставить чтение с записью в нашей программе:

  

| Thread 0 | Thread 1 |
| --- | --- |
| r1 = y | y = 1 |
| x = 1 | r2 = x |

  

Ведь такая имплементация может привести к результату `(r1, r2)=(0, 0)`:

  

| Thread 0 | Thread 1 |
| --- | --- |
| r1 = y // 0 |  |
|  | y = 1 |
|  | r2 = x // 0 |
| x = 1 |  |

  

А поэтому компилятору запрещается делать такую оптимизацию, ведь такой результат не входит в набор sequentially consistent результатов, который мы определили выше.

  

А вот, например, какую оптимизацию компилятор может сделать:

  

| Thread 0 | Thread 1 |
| --- | --- |
| r1 = 1 | r2 = 1 |

  

Компилятор полностью убрал записи и просто заинлайнил значения в чтения. Нарушает ли это Sequential Consistency? Совсем нет, ведь эта имплементация всегда приводит нас к результату `(r1, r2)=(1, 1)`, который является *sequentially consistent* результатом. То есть, если существует как минимум один sequentially consistent порядок, который дает такой результат, то такая оптимизация валидна. Конечно, это очень простой и наивный пример. Но расширьте обзор до всей программы и всех умных оптимизаций компилятора и JVM, и вы получите высоко-производительную программу, которая все равно выполняется полностью корректно.

  

Таким образом, представить себе работу SC модели памяти можно следующим образом:

  
1. Модель памяти "анализирует" оригинальную программу и исходя из порядка действий в программе "просчитывает" сет всех возможных sequentially consistent порядков и их результатов
2. С учетом получившегося сета результатов модель памяти разрешает делать любые оптимизации, пока они приводят к одному из sequentially consistent результатов, и запрещает делать такие оптимизации, которые могут привести к sequentially inconsistent результату
  

Что получается в итоге? А в итоге модель памяти, memory order, sequential consistency — это все абстракция между нами, пользователями JMM, и собственно самой имплементацией JMM. Нам данные абстракции позволяют нам рассуждать о корректности нашей программы без вдавания в низкоуровневые подробности, а разработчикам JMM делать любые оптимизации под капотом, пока они не нарушают этих абстракций. Однако в рамках данной статьи я все-таки покрою уровни ниже, чтобы иметь полную картину. В конце концов, как можно понять важность JMM, если не увидеть хоть части от всей сложности под капотом?

  

So, here's the deal: вы избавляетесь от всех *data race* в коде и получаете программу, результат которой будет всегда не отличим от одного из sequentially consistent порядков, а разработчики JMM получают возможность делать любые оптимизации под капотом, пока они приводят к валидному результату.

  

---

  
