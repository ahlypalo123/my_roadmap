## Введение: Memory Ordering

  

Для полного понимания модели памяти нам необходимо разобрать такое понятие как "memory ordering".

  

**Memory Ordering** описывает *наблюдаемый программой* порядок, в котором происходят действия с памятью.

  

Смотрите: со стороны программы есть только действия записи/чтения и их порядок в коде. Также со стороны программы кажется, что мы имеем единую общую память, записи в которую становятся сразу видны другим тредам. Программа не подозревает ни о каких instruction scheduling reordering/out-of-order execution/caching/register allocation и прочих оптимизациях под капотом. Если по какой-то причине мы наблюдаем результат, не консистентный с порядком в программе, то со стороны программы (высокоуровнево) это выглядит так, что действия c памятью просто были переупорядочены. Другими словами, *порядок взаимодействия с памятью (memory order) может отличаться от порядка действий в коде (program order)*.

  

Для большего понимания давайте взглянем на уже знакомую нам программу с точки зрения Memory Ordering:

  

| Thread 0 | Thread 1 |
| --- | --- |
| x = 1 | y = 1 |
| r1 = y | r2 = x |

  

В случае результата выполнения `(r1, r2) = (0, 0)` мы можем просто сказать, что *произошел `StoreLoad` memory reordering*, то есть запись произошла после чтения. Не важно, по какой низкоуровневой причине это случилось, а важно лишь то, что в итоге со стороны программы действия с памятью были выполнены в неконсистентном порядке.

  

Таким образом, в многопоточной программе нам важно знать ответы на следующие вопросы:

  
1. **Как сохраняется порядок программы при работе с памятью?**
2. **Валиден ли наблюдаемый memory order?**
  

Дать ответ на каждый из вопросов — это и есть задача модели памяти. Java Memory Model разрешает все возможные переупорядочивания в отсутствие синхронизации, поэтому ответ на эти вопросы такой:

  
1. Если программа не синхронизирована, то разрешены все переупорядочивания. Если программа правильно синхронизирована, запрещены все переупорядочивания
2. Если программа не синхронизирована, то memory order, неконсистентный с program order, валиден с точки зрения JMM. Если программа правильно синхронизирована, то валиден *только* консистентный порядок
  

Ваша программа отрабатывает в одном из порядков, валидных с точки зрения JMM. Таким образом, если программа не правильно синхронизирована, не стоит удивляться некорретному результату выполнения. Ведь важно то, валиден ли результат выполнения с точки зрения модели памяти, а не то, валиден он или нет для вас как пользователя.

  

Однако то, что какой-то неконсистентный порядок валиден, еще не значит, что вы всегда получите некорректный результат, ведь и консистентный порядок возможен в отсутствие синхронизации — это вы могли видеть по jcstress тесту, который является вероятностным. Понятно, что вы не хотите надеяться на волю случая, поэтому необходимо ограничить возможный сет порядков выполнения до только консистентных. А для этого необходимо использовать предоставляемые моделью примитивы синхронизации, которые мы рассмотрим позднее.

  

В свою очередь, *Memory Reordering* — это высокоуровневое понятие, которое абстрагирует и обобщает низкоуровневые проблемы, которые мы рассматривали выше. Всего существует 4 типа memory reordering:

  
1. *LoadLoad*: переупорядочивание чтений с другими чтениями. Например, действия `r1, r2` могут выполниться в порядке `r2, r1`
2. *LoadStore*: переупорядочивание чтений с записями, идущими позже в порядке программы. Например, действия `r, w` могут выполниться в порядке `w, r`
3. *StoreStore*: переупорядочивание записей с другими записями. Например, действия `w1, w2` могут выполниться в порядке `w2, w1`
4. *StoreLoad*: переупорядочивание записей с чтениями, идущими позже в порядке программы. Например, действия `w, r` могут выполниться в порядке `r, w`
  

В дальнейшем, когда я буду говорить "переупорядочивание" или "reordering", я буду иметь в виду именно Memory Reordering, если не сказано обратное.

  

*Memory Model* описывает, какие переупорядочивания возможны. В зависимости от строгости модели памяти подразделяются на следующие типы:

  
1. *Sequential Consistency*: запрещены все переупорядочивания
2. *Relaxed Consistency*: разрешены некоторые переупорядочивания
3. *Weak Consistency*: разрешены все переупорядочивания
  

Модель памяти существует как на уровне языка, так и на уровне процессора, но они не связаны напрямую. Модель языка может предоставлять как более слабые, так и более строгие гарантии, чем модель процессора.

  

В частности, как уже было сказано выше, Java Memory Model не дает никаких гарантий, пока не использованы необходимые примитивы синхронизации. И напротив, посмотрите на главу Memory Ordering из [Intel Software Developer’s Manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf#G13.14501):

  

> - Reads are not reordered with other reads \[запрещает LoadLoad reordering\]
> - Writes are not reordered with older reads \[запрещает LoadStore reordering\]
> - Writes to memory are not reordered with other writes \[запрещает StoreStore reordering\]
> - Reads may be reordered with older writes to different locations but not with older writes to the same location \[разрешает StoreLoad reordering\]
>   

Как видите, Intel разрешает только `StoreLoad` переупорядочивания, а все остальные запрещены. Да, модель памяти x86 достаточно строга, но есть и намного более слабые модели памяти процессоров — например, ARM разрешает все переупорядочивания.

  

Однако даже если вы пишете программу под x86, вам все равно необходимо считаться с более слабой Java Memory Model, так как последняя разрешает все переупорядочивания на уровне компилятора. *Модель памяти языка — прежде всего.*

  

---

  

### Memory Ordering vs Instructions Ordering

  

Еще раз закрепим: Memory Ordering и Instructions Ordering — это не одно и то же. Инструкции могут переупорядочиваться под капотом как угодно, но их *memory effect* должен подчиняться некоторым Memory Ordering правилам, которые гарантируются (или не гарантируются) Memory Model. Наконец, *memory ordering* — это высокоуровневое понятие, созданное для простоты понимания работы с памятью.

  

Например, Intel запрещает `LoadLoad` переупорядочивания, но под капотом все равно делает спекулятивные чтения. Как это возможно? Дело в том, что процессор следит за тем, чтобы результат выполнения инструкций не нарушал memory ordering правил. Если какое-то правило нарушается, то процессор возвращается к более раннему состоянию: результат чтения отбрасывается, а записи не коммитятся в память. Например, из того же [Intel Software Developer’s Manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf#G13.31870):

  

> The processor-ordering model described in this section is virtually identical to that used by the Pentium and Intel486 processors. The only enhancements in the Pentium 4, Intel Xeon, and P6 family processors are:  
> - Added support for speculative reads, while still adhering to the ordering principles above.
>   

  

---

  
