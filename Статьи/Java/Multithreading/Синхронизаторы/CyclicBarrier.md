#### CyclicBarrier

  
CyclicBarrier реализует шаблон синхронизации [Барьер](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F). Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (`CyclicBarrier(int parties)` и `CyclicBarrier(int parties, Runnable barrierAction)`) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».  
  
![](https://habrastorage.org/files/89a/f0c/b71/89af0cb71aad4465bb9c934b8be91a67.gif)  
  
Барьер похож на CountDownLatch, но главное различие между ними в том, что вы не можете заново использовать «замок» после того, как его счётчик достигнет нуля, а барьер вы можете использовать снова, даже после того, как он сломается. CyclicBarrier является альтернативой метода `join()`, который «собирает» потоки только после того, как они выполнились.  
  
[Официальная документация по CyclicBarrier.](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html)  
  

**Пример использования CyclicBarrier**

Рассмотрим следующий пример. Существует паромная переправа. Паром может переправлять одновременно по три автомобиля. Чтобы не гонять паром лишний раз, нужно отправлять его, когда у переправы соберется минимум три автомобиля.  
  
```java
import java.util.concurrent.CyclicBarrier;

public class Ferry {
    private static final CyclicBarrier BARRIER = new CyclicBarrier(3, new FerryBoat());
    //Инициализируем барьер на три потока и таском, который будет выполняться, когда
    //у барьера соберется три потока. После этого, они будут освобождены.

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 9; i++) {
            new Thread(new Car(i)).start();
            Thread.sleep(400);
        }
    }

    //Таск, который будет выполняться при достижении сторонами барьера
    public static class FerryBoat implements Runnable {
        @Override
        public void run() {
            try {
                Thread.sleep(500);
                System.out.println("Паром переправил автомобили!");
            } catch (InterruptedException e) {
            }
        }
    }

    //Стороны, которые будут достигать барьера
    public static class Car implements Runnable {
        private int carNumber;

        public Car(int carNumber) {
            this.carNumber = carNumber;
        }

        @Override
        public void run() {
            try {
                System.out.printf("Автомобиль №%d подъехал к паромной переправе.\n", carNumber);
                //Для указания потоку о том что он достиг барьера, нужно вызвать метод await()
                //После этого данный поток блокируется, и ждет пока остальные стороны достигнут барьера
                BARRIER.await();
                System.out.printf("Автомобиль №%d продолжил движение.\n", carNumber);
            } catch (Exception e) {
            }
        }
    }
}
```
  

**Результат работы программы**

Автомобиль №0 подъехал к паромной переправе.  
Автомобиль №1 подъехал к паромной переправе.  
Автомобиль №2 подъехал к паромной переправе.  
Автомобиль №3 подъехал к паромной переправе.  
Паром переправил автомобили!  
Автомобиль №2 продолжил движение.  
Автомобиль №1 продолжил движение.  
Автомобиль №0 продолжил движение.  
Автомобиль №4 подъехал к паромной переправе.  
Автомобиль №5 подъехал к паромной переправе.  
Автомобиль №6 подъехал к паромной переправе.  
Паром переправил автомобили!  
Автомобиль №5 продолжил движение.  
Автомобиль №4 продолжил движение.  
Автомобиль №3 продолжил движение.  
Автомобиль №7 подъехал к паромной переправе.  
Автомобиль №8 подъехал к паромной переправе.  
Паром переправил автомобили!  
Автомобиль №8 продолжил движение.  
Автомобиль №6 продолжил движение.  
Автомобиль №7 продолжил движение.  

  
Когда три потока достигают метода `await()`, барьерное действие запускается, и паром переправляет три автомобиля из скопившихся. После этого начинается новый цикл.  

  
  
