---
title: "Вычислительный конвейер — Википедия"
source: "https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80"
author:
published:
created: 2025-04-27
description:
tags:
  - "clippings"
---
**Конве́йер** — способ организации вычислений, используемый в современных [процессорах](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80 "Процессор") и [контроллерах](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80 "Микроконтроллер") с целью повышения их производительности (увеличения числа инструкций, выполняемых в единицу времени — эксплуатация [параллелизма на уровне инструкций](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B7%D0%BC_%D0%BD%D0%B0_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4 "Параллелизм на уровне команд")).

Идея заключается в параллельном выполнении нескольких инструкций процессора. Сложные инструкции процессора представляются в виде последовательности более простых стадий. Вместо выполнения инструкций последовательно (ожидания завершения конца одной инструкции и перехода к следующей), следующая инструкция может выполняться через несколько стадий выполнения первой инструкции. Это позволяет управляющим цепям процессора получать инструкции со скоростью самой медленной стадии обработки, но при этом, намного быстрее, чем при выполнении эксклюзивной полной обработки каждой инструкции от начала до конца.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Fivestagespipeline.png/500px-Fivestagespipeline.png)

Простой пятиуровневый конвейер в RISC-процессорах

На иллюстрации показан простой пятиуровневый конвейер в [RISC](https://ru.wikipedia.org/wiki/RISC "RISC") -процессорах. Здесь:

- IF ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Instruction Fetch) — получение [инструкции](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F_\(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0\) "Инструкция (информатика)"),
- ID ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Instruction Decode) — раскодирование инструкции,
- EX ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Execute) — выполнение,
- MEM ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Memory access) — доступ к [памяти](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C "Оперативная память"),
- WB ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Register write back) — запись в регистр.

Вертикальная ось — последовательные независимые инструкции, горизонтальная — время. Зелёная колонка описывает состояние процессора в один момент времени, в ней самая ранняя, верхняя инструкция уже находится в состоянии записи в регистр, а самая последняя, нижняя инструкция — только в процессе чтения.

- арифметический конвейер (arithmetic pipeline) — реализация в [АЛУ](https://ru.wikipedia.org/wiki/%D0%90%D0%9B%D0%A3 "АЛУ") поэтапного исполнения арифметических операций чаще всего над вещественными числами
- супер-конвейер, гипер-конвейер, глубокий конвейер (super-pipeline, hyper-pipeline, deep pipeline) — вычислительный конвейер с необычно большим количеством стадий. Например, процессор Intel [Pentium 4](https://ru.wikipedia.org/wiki/Pentium_4 "Pentium 4") имел 20 стадий конвейера, а в модификации [Prescott](https://ru.wikipedia.org/wiki/Pentium_4#Prescott "Pentium 4") получил конвейер из 31 стадии [^1].
- недозагруженный конвейер (underutilized pipeline) — конвейер, в котором в одно и то же время не все стадии конвейера выполняют какую-то операцию. Например ранние [процессоры MIPS](https://ru.wikipedia.org/wiki/MIPS_\(%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0\) "MIPS (архитектура)") имели 6-стадийный конвейер, но в каждый момент было занято только 3 его стадии.

Сам термин «конвейер» пришёл из промышленности, где используется [подобный принцип работы](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE "Конвейерное производство") — материал автоматически подтягивается по ленте [конвейера](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80 "Конвейер") к рабочему, который осуществляет с ним необходимые действия, следующий за ним рабочий выполняет свои функции над получившейся заготовкой, следующий делает ещё что-то. Таким образом, к концу конвейера цепочка рабочих полностью выполняет все поставленные задачи, сохраняя высокий темп производства. Например, если на самую медленную операцию затрачивается одна минута, то каждая деталь будет сходить с конвейера через одну минуту. В процессорах роль рабочих исполняют функциональные модули, входящие в состав процессора.

Простейшая форма совмещения выполнения инструкций во времени была реализована в машине « [Z3](https://ru.wikipedia.org/wiki/Z3 "Z3") » [Конрада Цузе](https://ru.wikipedia.org/wiki/%D0%A6%D1%83%D0%B7%D0%B5,_%D0%9A%D0%BE%D0%BD%D1%80%D0%B0%D0%B4 "Цузе, Конрад") в 1941 году [^2].

Ламповая малая ЭЦВМ « [Урал](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%B0%D0%BB-1 "Урал-1") » ([1957 год](https://ru.wikipedia.org/wiki/1957_%D0%B3%D0%BE%D0%B4 "1957 год"), [СССР](https://ru.wikipedia.org/wiki/%D0%A1%D0%A1%D0%A1%D0%A0 "СССР")) имела двухступенчатый конвейер операций.[^3]

Многостадийные конвейеры в современном представлении были реализованы в машине [Анатолия Ивановича Китова](https://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D1%82%D0%BE%D0%B2,_%D0%90%D0%BD%D0%B0%D1%82%D0%BE%D0%BB%D0%B8%D0%B9_%D0%98%D0%B2%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%87 "Китов, Анатолий Иванович") « [М-100](https://ru.wikipedia.org/wiki/%D0%9C-100_\(%D1%8D%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%BE%D0%BD%D0%BD%D0%BE-%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%B0\) "М-100 (электронно-вычислительная машина)") » (1959 год, СССР) <sup>[<i><span title="Нужен источник, показывающий что конвейер М-100 был длиннее двух стадий, иначе это не конвейер, а просто предвыборка кода -- Avivanov76 11:27, 25 мая 2015 (UTC)">уточнить</span></i>]</sup> [^4],[UNIVAC LARC](https://ru.wikipedia.org/wiki/UNIVAC_LARC "UNIVAC LARC") (1960 год, США), [IBM Stretch](https://ru.wikipedia.org/wiki/IBM_7030_Stretch "IBM 7030 Stretch") (1961 год, США) [^5], [Atlas](https://ru.wikipedia.org/wiki/Atlas_\(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80\) "Atlas (компьютер)") (1962 год, Великобритания) и [БЭСМ-6](https://ru.wikipedia.org/wiki/%D0%91%D0%AD%D0%A1%D0%9C-6 "БЭСМ-6") (1967 год, СССР). В проекте IBM Stretch были предложены термины «выборка» ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Fetch), «декодирование» ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Decode) и «выполнение» ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Execute), которые затем стали общеупотребительными.

Многие современные [процессоры](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80 "Процессор") управляются тактовым генератором. Процессор внутри состоит из [логических элементов](https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B "Логические элементы") и ячеек памяти — [триггеров](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B8%D0%B3%D0%B3%D0%B5%D1%80_\(%D1%8D%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%BE%D0%BD%D0%B8%D0%BA%D0%B0\) "Триггер (электроника)"). Когда приходит сигнал от тактового генератора, триггеры приобретают своё новое значение, и «логике» требуется некоторое время для декодирования новых значений. Затем приходит следующий сигнал от тактового генератора, триггеры принимают новые значения, и так далее. Разбивая последовательности логических элементов на более короткие и помещая триггеры между этими короткими последовательностями, уменьшают время, необходимое логике для обработки сигналов. В этом случае длительность одного такта процессора может быть соответственно уменьшена.

Например, простейший конвейер [RISC](https://ru.wikipedia.org/wiki/RISC "RISC") -процессоров можно представить пятью стадиями с наборами триггеров между стадиями:

1. получение [инструкции](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F_\(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0\) "Инструкция (информатика)") ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Instruction Fetch);
2. декодирование инструкции ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Instruction Decode) и чтение регистров ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Register fetch);
3. выполнение ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Execute);
4. доступ к [памяти](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C "Оперативная память") ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Memory access);
5. запись в регистр ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Register write back).

Ситуации, называемые [конфликтами конвейера](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82_%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80%D0%B0&action=edit&redlink=1 "Конфликт конвейера (страница отсутствует)") ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")hazards), препятствуют выполнению очередной команды из потока команд в предназначенном для неё такте. Конфликты уменьшают реальное ускорение в производительности конвейерной обработки и могут вызвать необходимость [остановки конвейера](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B0 "Команда останова"). Для разрешения конфликта нужно, чтобы некоторые команды в конвейере могли продолжать выполняться, в то время как другие были задержаны.

Существует три класса конфликтов [^6].

Структурные конфликты возникают из-за конфликтов ресурсов, когда аппаратура не может поддерживать все возможные комбинации одновременно выполняемых команд [^7]. Если какая-то комбинация команд не может быть поддержана, то говорят, что [процессор](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80 "Процессор") имеет *структурный конфликт*. Наиболее часто структурные конфликты происходят, когда некоторый функциональный блок не полностью конвейеризован. Например, некоторые процессоры совместно используют единый конвейер памяти для данных и команд. В результате, когда команда содержит обращение к памяти данных, она вступает в конфликт с обращением более поздней командой. Чтобы этот конфликт разрешался при обращении к памяти за данными, конвейер приостанавливается на один такт.

В качестве альтернативы такому структурному конфликту разработчик мог бы обеспечить отдельное обращение к памяти команд либо путём разбиения кэша на отдельные кэш команд и кэш данных, либо используя множество буферов, называемыми *буферами команд* для хранения команд, однако, этого не делается во избежание увеличения стоимости блока [^8].

Конфликты по данным возникают, когда зависимость команды от результатов предыдущей проявляется при совмещении команд в конвейере. Данные конфликты происходят, когда конвейер изменяет порядок обращений считывания/записи к операндам так, что он отличается от порядка, который существует для последовательно выполняемых команд в процессоре без конвейера. Существует метод устранения конфликта по данным: [форвардинг](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82_%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80%D0%B0&action=edit&redlink=1 "Конфликт конвейера (страница отсутствует)") ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")[register forwarding](https://en.wikipedia.org/wiki/Hazard_\(computer_architecture\)#Register_forwarding "en:Hazard (computer architecture)")) (иногда называется [bypass](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B9%D0%BF%D0%B0%D1%81#%D0%91%D0%B0%D0%B9%D0%BF%D0%B0%D1%81_%D0%B2_%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80%D0%B5_%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%BE%D0%B2 "Байпас")) [^9]. К сожалению, не все потенциальные конфликты по данным можно обработать с помощью байпаса, в этом случае конвейер приостанавливается до разрешения конфликта.

Конфликты по управлению возникают при конвейерном выполнении условных передач управления и других команд, которые изменяют значение [программного счетчика](https://ru.wikipedia.org/wiki/%D0%A1%D1%87%D1%91%D1%82%D1%87%D0%B8%D0%BA_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4 "Счётчик команд"). Существует много способов обработки [остановки конвейера](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B0 "Команда останова"), вызванных задержкой передачи управления, но для глубоких конвейеров в основном используются агрессивные средства [^10], такие как [предсказания передач управления](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D0%BE%D0%B2 "Предсказатель переходов").

Бесконвейерная архитектура значительно менее эффективна из-за меньшей загрузки функциональных модулей [процессора](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80 "Процессор") в то время, пока один или небольшое число модулей выполняет свою функцию во время обработки инструкций. Конвейер не убирает полностью время простоя модулей в процессорах и не уменьшает время выполнения каждой конкретной инструкции, но заставляет модули процессора работать параллельно над разными инструкциями, увеличивая тем самым количество инструкций, выполняемых за единицу времени, а значит, и общую производительность программ.

Процессоры с конвейером внутри устроены так, что обработка инструкций разделена на последовательность стадий, предполагая одновременную обработку нескольких инструкций на разных стадиях. Результаты работы каждой из стадий передаются через ячейки памяти на следующую стадию, и так — до тех пор, пока инструкция не будет выполнена. Подобная организация процессора, при некотором увеличении среднего времени выполнения каждой инструкции, тем не менее, обеспечивает значительный рост производительности за счёт высокой частоты завершения выполнения инструкций.

Однако не все инструкции являются независимыми. В простейшем конвейере, где обработка инструкции представлена пятью стадиями, для обеспечения полной загрузки, в то время, пока заканчивается обработка первой инструкции, в идеале, должно обрабатываться параллельно ещё четыре последовательных независимых инструкции. Если последовательность содержит инструкции, зависимые от выполняемых в данный момент, то управляющая логика простейшего конвейера приостанавливает несколько начальных стадий конвейера, помещая этим самым в конвейер пустую инструкцию («пузырёк»), иногда неоднократно, — до тех пор, пока зависимость не будет разрешена. Существует ряд приёмов, таких, как форвардинг, значительно снижающих необходимость приостанавливать в таких случаях часть конвейера. Однако зависимость между инструкциями, одновременно обрабатываемыми процессором, не позволяет добиться увеличения производительности кратно количеству стадий конвейера в сравнении с бесконвейерным процессором.

Конвейер помогает не во всех случаях. Существует несколько возможных минусов. Конвейер инструкций можно назвать «полностью конвейерным», если он может принимать новую инструкцию каждый [машинный цикл](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D1%86%D0%B8%D0%BA%D0%BB "Машинный цикл"). Иначе в конвейер должны быть вынужденно вставлены задержки, которые выравнивают конвейер, при этом ухудшая его производительность.

Преимущества:

1. Время цикла процессора уменьшается, таким образом увеличивая скорость обработки инструкций в большинстве случаев.
2. Некоторые комбинационные логические элементы, такие, как [сумматоры](https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%BC%D0%BC%D0%B0%D1%82%D0%BE%D1%80 "Сумматор") или умножители, могут быть ускорены путём увеличения количества логических элементов. Использование конвейера может предотвратить ненужное наращивание количества элементов.

Недостатки:

1. Бесконвейерный процессор исполняет только одну инструкцию за раз. Это предотвращает задержки веток инструкций (фактически каждая ветка задерживается), и проблемы, связанные с последовательными инструкциями, которые исполняются параллельно. Следовательно, схема такого процессора проще, и он дешевле для изготовления.
2. Задержка инструкций в бесконвейерном процессоре слегка ниже, чем в конвейерном эквиваленте. Это происходит из-за того, что в конвейерный процессор должны быть добавлены дополнительные [триггеры](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B8%D0%B3%D0%B3%D0%B5%D1%80 "Триггер").
3. У бесконвейерного процессора скорость обработки инструкций стабильна. Производительность конвейерного процессора предсказать намного сложнее, и она может значительно различаться в разных программах.
![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/Pipeline%2C_4_stage.svg/350px-Pipeline%2C_4_stage.svg.png)

Общий четырёхуровневых конвейер; цветные квадраты символизируют независимые друг от друга инструкции

Справа изображён общий конвейер с четырьмя стадиями работы:

1. Получение ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Fetch)
2. Раскодирование ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Decode)
3. Выполнение ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Execute)
4. Запись результата ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык")Write-back)

Верхняя серая область — список инструкций, которые предстоит выполнить. Нижняя серая область — список инструкций, которые уже были выполнены. И средняя белая область является самим конвейером.

Выполнение происходит следующим образом:

| Цикл | Действия |
| --- | --- |
| 0 | Четыре инструкции ожидают исполнения |
| 1 | - Зелёная инструкция забирается из памяти |
| 2 | - Зелёная инструкция раскодируется - Фиолетовая инструкция забирается из памяти |
| 3 | - Зелёная инструкция выполняется (то есть исполняется то действие, которое она кодировала) - Фиолетовая инструкция раскодируется - Синяя инструкция забирается из памяти |
| 4 | - Итоги исполнения зелёной инструкции записываются в регистры или в память - Фиолетовая инструкция выполняется - Синяя инструкция раскодируется - Красная инструкция забирается из памяти |
| 5 | - Зелёная инструкция завершилась - Итоги исполнения фиолетовой инструкции записываются в регистры или в память - Синяя инструкция выполняется - Красная инструкция раскодируется |
| 6 | - Фиолетовая инструкция завершилась - Результаты исполнения синей инструкции записываются в регистры или в память - Красная инструкция выполняется |
| 7 | - Синяя инструкция завершилась - Итоги исполнения красной инструкции записываются в регистры или в память |
| 8 | - Красная инструкция завершилась |
| 9 | Все инструкции были выполнены |

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Pipeline%2C_4_stage_with_bubble.svg/500px-Pipeline%2C_4_stage_with_bubble.svg.png)

Пузырек в третьем такте обработки задерживает исполнение

Для разрешения конфликтов конвейера процессор вынужден задерживать обработку инструкции путём создания «пузырька» (bubble) в конвейере. Прохождение пузырька через исполнительные устройства не сопровождается никакой полезной работой. Во втором такте обработка фиолетовой инструкции задерживается, и на стадии декодирования в третьем такте теперь находится пузырёк. Все инструкции, следующие «за» фиолетовой инструкцией, задерживаются на один такт, тогда как инструкции, находящиеся «перед» фиолетовой инструкцией, продолжают исполняться.

Очевидно, что наличие пузырька в конвейере даёт суммарное время исполнения в 8 тактов вместо 7 на схеме исполнения, показанной выше.

Исполнительные устройства должны выполнять какое-то действие на каждом такте. Пузырьки являются способом создания задержки при обработке инструкции без прекращения работы конвейера. При их выполнении не происходит полезной работы на стадиях выборки, декодирования, исполнения и записи результата. Они могут быть выражены при помощи инструкции [NOP](https://ru.wikipedia.org/wiki/NOP "NOP") [^11] [^12] [^13] [ассемблера](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%D0%B0 "Язык ассемблера").

Допустим, типичная инструкция для сложения двух чисел — это `СЛОЖИТЬ A, B, C`. Эта инструкция суммирует значения, находящиеся в ячейках памяти *A* и *B*, а затем кладет результат в ячейку памяти *C*. В конвейерном процессоре контроллер может разбить эту операцию на последовательные задачи вида

```
ЗАГРУЗИТЬ A, R1
ЗАГРУЗИТЬ B, R2
СЛОЖИТЬ R1, R2, R3
ЗАПИСАТЬ R3, C
загрузить следующую инструкцию
```

Ячейки *R1*, *R2* и *R3* являются [регистрами](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0 "Регистр процессора") [процессора](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80 "Процессор"). Значения, которые хранятся в ячейках памяти, которые мы называем *A* и *B*, загружаются (то есть копируются) в эти регистры, затем суммируются, и результат записывается в ячейку памяти *C*.

В данном примере конвейер состоит из трех уровней — загрузки, исполнения и записи. Эти шаги называются, очевидно, *уровнями* или *шагами конвейера*.

В бесконвейерном процессоре только один шаг может работать в один момент времени, поэтому инструкция должна полностью закончиться прежде, чем следующая инструкция, в принципе, начнется. В конвейерном процессоре все эти шаги могут выполняться одновременно на разных инструкциях. Поэтому, когда первая инструкция находится на шаге исполнения, вторая инструкция будет на стадии раскодирования, а третья инструкция будет на стадии прочтения.

Конвейер не уменьшает время, которое необходимо для того, чтобы выполнить инструкцию, но зато он увеличивает объём (число) инструкций, которые могут быть выполнены одновременно, и таким образом уменьшает задержку между выполненными инструкциями — увеличивая т. н. *пропускную способность*. Чем больше уровней имеет конвейер, тем больше инструкций могут выполняться одновременно и тем меньше задержка между завершенными инструкциями. Каждый микропроцессор, произведенный в наши дни, использует как минимум двухуровневый конвейер.

Теоретический трёхуровневый конвейер:

| Шаг | Англ. название | Описание |
| --- | --- | --- |
| Выборка | Fetch | Прочитать инструкцию из памяти |
| Исполнение | Execute | Исполнить инструкцию |
| Запись | Write-back | Записать результат в память и/или регистры |

Псевдоассемблерный листинг, который нужно выполнить:

```
ЗАГРУЗИТЬ  40, A       ; загрузить число 40 в A
КОПИРОВАТЬ A,  B       ; скопировать A в B
СЛОЖИТЬ    20, B       ; добавить 20 к B
ЗАПИСАТЬ   B,  0x0300  ; записать B в ячейку памяти 0x0300
```

Как это будет исполняться:

| Такт | Выборка | Исполнение | Запись | Пояснение |
| --- | --- | --- | --- | --- |
| Такт 1 | ЗАГРУЗИТЬ |  |  | Инструкция ЗАГРУЗИТЬ читается из памяти. |
| Такт 2 | КОПИРОВАТЬ | ЗАГРУЗИТЬ |  | Инструкция ЗАГРУЗИТЬ выполняется, инструкция КОПИРОВАТЬ читается из памяти. |
| Такт 3 | СЛОЖИТЬ | КОПИРОВАТЬ | ЗАГРУЗИТЬ | Инструкция ЗАГРУЗИТЬ находится на шаге записи результата, где её результат (то есть число *40*) записывается в регистр *А*. В это же время инструкция КОПИРОВАТЬ исполняется. Так как она должна скопировать содержимое регистра *A* в регистр *B*, она должна дождаться окончания инструкции ЗАГРУЗИТЬ. |
| Такт 4 | ЗАПИСАТЬ | СЛОЖИТЬ | СКОПИРОВАТЬ | Загружена инструкция ЗАПИСАТЬ, тогда как инструкция СКОПИРОВАТЬ прощается с нами, а по инструкции СЛОЖИТЬ в данный момент производятся вычисления. |

И так далее. Следует учитывать, что иногда инструкции будут зависеть от итогов других инструкций (например, как наша инструкция КОПИРОВАТЬ). Когда более, чем одна инструкция ссылается на определённое место, читая его (то есть используя в качестве входного операнда) либо записывая в него (то есть используя его в качестве выходного операнда), исполнение инструкций не в порядке, который был изначально запланирован в оригинальной программе, может повлечь за собой [конфликт конвейера](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82_%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80%D0%B0&action=edit&redlink=1 "Конфликт конвейера (страница отсутствует)"), (о чём упоминалось выше). Существует несколько зарекомендовавших себя приёмов либо для предотвращения конфликтов, либо для их исправления, если они случились.

Многие процессоры имеют конвейеры в 7, 10 или даже 20 уровней (как, например, в процессоре [Pentium 4](https://ru.wikipedia.org/wiki/Pentium_4 "Pentium 4")). Поздние ядра Pentium 4 с кодовыми именами [Prescott](https://ru.wikipedia.org/wiki/Prescott "Prescott") и [Cedar Mill](https://ru.wikipedia.org/wiki/Cedar_Mill "Cedar Mill") (и их [Pentium D](https://ru.wikipedia.org/wiki/Pentium_D "Pentium D") -производные) имеют 31-уровневый конвейер.

Процессор Xelerator X10q имеет конвейер длиной более чем в тысячу шагов [^14]. Обратной стороной медали в данном случае является необходимость сбрасывать весь конвейер в случае, если ход программы изменился (например, по условному оператору). Эту проблему пытаются решать [предсказатели переходов](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D0%BE%D0%B2 "Предсказатель переходов"). Предсказание переходов само по себе может только усугубить ситуацию, если предсказание производится плохо. В некоторых областях применения, таких, как вычисления на [суперкомпьютерах](https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%BF%D0%B5%D1%80%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80 "Суперкомпьютер"), программы специально пишутся так, чтобы как можно реже использовать условные операторы, поэтому очень длинные конвейеры весьма позитивно скажутся на общей скорости вычислений, так как длинные конвейеры проектируются так, чтобы уменьшить CPI ([количество тактов на инструкцию](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D1%82%D0%B0%D0%BA%D1%82%D0%BE%D0%B2_%D0%BD%D0%B0_%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8E&action=edit&redlink=1 "Количество тактов на инструкцию (страница отсутствует)")).

Если ветвление происходит постоянно, значительно уменьшить потери скорости поможет перестановка машинных инструкций: в конвейере размещаются те инструкции, которые, скорее всего, понадобятся. Этот способ более эффективен по сравнению с необходимостью каждый раз полностью сбрасывать конвейер.

Высокая пропускная способность конвейеров приводит к уменьшению производительности в случае, если в исполняемом коде содержится много условных переходов: процессор не знает, откуда читать следующую инструкцию, и поэтому вынужден ждать, когда закончится инструкция условного перехода, оставляя за ней пустой конвейер. После того, как ветка будет пройдена и станет известно, куда процессору необходимо переходить в дальнейшем, следующая инструкция должна будет пройти весь путь через конвейер перед тем, как результат становится доступным и процессор снова «работает». В крайнем случае производительность конвейерного процессора может теоретически упасть до производительности бесконвейерного, или даже быть хуже за счёт того, что будет занят только один уровень конвейера и между уровнями присутствует небольшая задержка.

Если процессор оснащён конвейером, код, читаемый из памяти, не выполняется сразу, а помещается в очередь (очередь предвыборки, [prefetch input queue](https://en.wikipedia.org/wiki/Prefetch_input_queue "en:Prefetch input queue")). Если код, содержащийся в памяти, будет изменён, код, содержащийся в очереди конвейера, останется прежним. Также не изменятся инструкции, находящиеся в [кэше инструкций](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0 "Кэш процессора"). Стоит учитывать, что данная проблема характерна только для [самомодифицирующихся программ](https://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%BC%D0%BE%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B9%D1%81%D1%8F_%D0%BA%D0%BE%D0%B4 "Самомодифицирующийся код") и [упаковщиков](https://ru.wikipedia.org/wiki/%D0%A3%D0%BF%D0%B0%D0%BA%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D1%85_%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2 "Упаковка исполняемых файлов") [исполняемых](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D0%BC%D1%8B%D0%B9_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C "Исполнимый модуль") файлов.

- [Параллельные вычислительные системы](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B "Параллельные вычислительные системы")
- [Макроконвейер](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80 "Макроконвейер")
- [Программная конвейеризация](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%B0%D1%8F_%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F "Программная конвейеризация")
- *Amos R. Omondi.*[Microarchitecture of Pipelined and Superscalar Computers](https://books.google.ru/books?id=-_LiBwAAQBAJ). — Springer, 1999. — 266 p. — [ISBN 1441950818](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/1441950818).(англ.)
- *David A. Patterson, John L. Hennessy.*[Computer Organization and Design: The Hardware/Software Interface, 5th Edition](https://books.google.ru/books?id=EVhgAAAAQBAJ). — Morgan Kaufmann, 2013. — 800 p. — [ISBN 0124077269](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/0124077269).(англ.)
- *David A. Patterson.* Computer Architecture, Fifth Edition: A Quantitative Approach. — 5. — Morgan Kaufmann, 2011. — 856 p. — (Series in Computer Architecture and Design). — [ISBN 978-0123838728](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/9780123838728).
- *Воеводин Вл. В.*[Параллельная обработка данных](http://www.parallel.ru/vvv/lec1.html) (лекции). Раздел «Конвейерная обработка».
- [Предсказание ветвлений в процессорах семейства Pentium](https://web.archive.org/web/20070927195431/http://x86.org/articles/branch/branchprediction.htm) (англ.)
- [Статья по конвейерам](http://arstechnica.com/articles/paedia/cpu/pipelining-1.ars/1) (англ.) на ArsTechnica
- [Архитектура процессора с противоточным конвейером](https://web.archive.org/web/20080604095314/http://research.sun.com/techrep/1994/abstract-25.html) (англ.)
- [Влияние длины конвейера. Исследование эффективности ALU и FPU процессоров разных поколений](https://web.archive.org/web/20121011013238/http://testlabs.kz/processors/25-golaya-proizvoditelnost-issleduem-effektivnost-alu-i-fpu.html) от TestLabs.kz

[^1]: *Glaskowsky, Peter N.*[Prescott Pushes Pipelining Limits](http://www.cs.virginia.edu/~mc2zk/cs451/180501.pdf) [Архивная копия](https://web.archive.org/web/20170408012321/http://www.cs.virginia.edu/~mc2zk/cs451/180501.pdf) от 8 апреля 2017 на [Wayback Machine](https://ru.wikipedia.org/wiki/Wayback_Machine "Wayback Machine") // Microprocessor Report, 2 February 2004 (англ.)

[^2]: *Raúl Rojas.*[The First Computers: History and Architectures](https://books.google.ru/books?id=nDWPW9uwZPAC&pg=PA249#v=onepage&q&f=false). — MIT Press, 2002. — С. 249. — 472 с. — [ISBN 0-262-68137-4](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/0262681374).

[^3]: *Смольников Н. Я.*[Основы программирования для цифровой машины «Урал»](http://emural.clan.su/file_archive/Smolnikov_programmirovanie_ural.djvu). — Советское радио, 1961. — С. 83. — 328 с.

[^4]: *Ревич Юрий Всеволодович, Малиновский Б.*[Информационные технологии в СССР. Создатели советской компьютерной техники](http://it-history.ru/images/6/63/AIKitov_Revich.pdf). — БХВ-Петербург, 2014. — 336 с. [Архивировано](https://web.archive.org/web/20151222153202/http://it-history.ru/images/6/63/AIKitov_Revich.pdf) 22 декабря 2015 года.

[^5]: *Harvey G. Cragon.*[Memory Systems and Pipelined Processors](https://books.google.ru/books?id=q2w3JSFD7l4C&pg=PA289#v=onepage&q&f=false). — Jones and Bartlett Learning, 1996. — С. 289. — 575 с. — [ISBN 0-86720-474-5](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/0867204745).

[^6]: [Morgan Kaufmann Publishers](https://ru.wikipedia.org/wiki/Morgan_Kaufmann_Publishers "Morgan Kaufmann Publishers"), *Computer Organization and Design*, [David A. Patterson](https://ru.wikipedia.org/wiki/David_Patterson_\(scientist\) "David Patterson (scientist)") & [John L. Hennessy](https://ru.wikipedia.org/wiki/John_L._Hennessy "John L. Hennessy"), Edition 3, [ISBN 1-55860-604-1](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/1558606041), page 738

[^7]: [Morgan Kaufmann Publishers](https://ru.wikipedia.org/wiki/Morgan_Kaufmann_Publishers "Morgan Kaufmann Publishers"), *Computer Organization and Design*, [David A. Patterson](https://ru.wikipedia.org/wiki/David_Patterson_\(scientist\) "David Patterson (scientist)") & [John L. Hennessy](https://ru.wikipedia.org/wiki/John_L._Hennessy "John L. Hennessy"), Edition 3, [ISBN 1-55860-604-1](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/1558606041), page 740

[^8]: [Morgan Kaufmann Publishers](https://ru.wikipedia.org/wiki/Morgan_Kaufmann_Publishers "Morgan Kaufmann Publishers"), *Computer Organization and Design*, [David A. Patterson](https://ru.wikipedia.org/wiki/David_Patterson_\(scientist\) "David Patterson (scientist)") & [John L. Hennessy](https://ru.wikipedia.org/wiki/John_L._Hennessy "John L. Hennessy"), Edition 3, [ISBN 1-55860-604-1](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/1558606041), page 743

[^9]: [Morgan Kaufmann Publishers](https://ru.wikipedia.org/wiki/Morgan_Kaufmann_Publishers "Morgan Kaufmann Publishers"), *Computer Organization and Design*, [David A. Patterson](https://ru.wikipedia.org/wiki/David_Patterson_\(scientist\) "David Patterson (scientist)") & [John L. Hennessy](https://ru.wikipedia.org/wiki/John_L._Hennessy "John L. Hennessy"), Edition 3, [ISBN 1-55860-604-1](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/1558606041), page 745

[^10]: [Morgan Kaufmann Publishers](https://ru.wikipedia.org/wiki/Morgan_Kaufmann_Publishers "Morgan Kaufmann Publishers"), *Computer Organization and Design*, [David A. Patterson](https://ru.wikipedia.org/wiki/David_Patterson_\(scientist\) "David Patterson (scientist)") & [John L. Hennessy](https://ru.wikipedia.org/wiki/John_L._Hennessy "John L. Hennessy"), Edition 3, [ISBN 1-55860-604-1](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%98%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8_%D0%BA%D0%BD%D0%B8%D0%B3/1558606041), page 756

[^11]: «For the stall case, a bubble (NOP instruction) is sent to the next stage of pipeline and all previous stages stall for a time-step» // [CPU — 32bit RISC](http://www.cs.washington.edu/homes/duhao/Projects/CPURisc/CPU32Riscwebsite.html) [Архивная копия](https://web.archive.org/web/20111104085836/http://www.cs.washington.edu/homes/duhao/Projects/CPURisc/CPU32Riscwebsite.html) от 4 ноября 2011 на [Wayback Machine](https://ru.wikipedia.org/wiki/Wayback_Machine "Wayback Machine")

[^12]: «stream a pipeline bubble, or NOP, must be inserted» // [Instruction Level Parallelism in VLIW Processors](http://www.cse.unsw.edu.au/~cs9244/03/seminars/02-cgray.ps.gz) [Архивная копия](https://web.archive.org/web/20080920111922/http://www.cse.unsw.edu.au/~cs9244/03/seminars/02-cgray.ps.gz) от 20 сентября 2008 на [Wayback Machine](https://ru.wikipedia.org/wiki/Wayback_Machine "Wayback Machine")

[^13]: «Bubbles are NOP instructions» // [Pipelined Processor Design](http://faculty.kfupm.edu.sa/COE/mudawar/coe308/lectures/10-PipelinedProcessor.ppt) [Архивная копия](https://web.archive.org/web/20170103165042/http://faculty.kfupm.edu.sa/COE/mudawar/coe308/lectures/10-PipelinedProcessor.ppt) от 3 января 2017 на [Wayback Machine](https://ru.wikipedia.org/wiki/Wayback_Machine "Wayback Machine")

[^14]: [The Linley Group — Best Extreme Processor: Xelerated X10q](http://www.linleygroup.com/newsletters/newsletter_detail.php?num=4501). Дата обращения: 17 ноября 2012. [Архивировано](https://web.archive.org/web/20131215220102/http://www.linleygroup.com/newsletters/newsletter_detail.php?num=4501) 15 декабря 2013 года.